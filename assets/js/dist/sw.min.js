---
permalink: /:basename
---

(function () {
  'use strict';

  var data = { theme:"jekyll-theme-chirpy",
    lang:"en",
    timezone:"Asia/Seoul",
    title:"rebedy",
    tagline:"Through research, I'm re-being.",
    description:"A beautiful life with research.",
    url:"https://rebedy.github.io",
    github:{ username:"rebedy" },
    twitter:{ username:"rebedy17" },
    social:{ name:"Dyan Lee",
      email:"dyan.lee717@gmail.com",
      links:[ "https://twitter.com/rebedy17",
        "https://github.com/rebedy",
        "https://www.linkedin.com/in/dyanlee" ] },
    webmaster_verifications:{ google:null,
      bing:null,
      alexa:null,
      yandex:null,
      baidu:null,
      facebook:null },
    analytics:{ google:{ id:null },
      goatcounter:{ id:null },
      umami:{ id:null,
        domain:null },
      matomo:{ id:null,
        domain:null },
      cloudflare:{ id:null } },
    pageviews:{ provider:null },
    theme_mode:null,
    cdn:"https://rebedy.netlify.app",
    avatar:"/assets/img/favicons/apple-touch-icon.png",
    social_preview_image:null,
    toc:true,
    comments:{ provider:null,
      disqus:{ shortname:null },
      utterances:{ repo:null,
        issue_term:null },
      giscus:{ repo:null,
        repo_id:null,
        category:null,
        category_id:null,
        mapping:null,
        strict:null,
        input_position:null,
        lang:null,
        reactions_enabled:null } },
    assets:{ self_host:{ enabled:null,
        env:null } },
    pwa:{ enabled:true,
      cache:{ enabled:true,
        deny_paths:null } },
    paginate:10,
    baseurl:"",
    kramdown:{ footnote_backlink:"&#8617;&#xfe0e;",
      syntax_highlighter:"rouge",
      syntax_highlighter_opts:{ css_class:"highlight",
        span:{ line_numbers:false },
        block:{ line_numbers:true,
          start_line:1 } } },
    collections:{ tabs:{ output:true,
        sort_by:"order" } },
    defaults:[ { scope:{ path:"",
          type:"posts" },
        values:{ layout:"post",
          comments:true,
          toc:true,
          permalink:"/posts/:title/" } },
      { scope:{ path:"_drafts" },
        values:{ comments:false } },
      { scope:{ path:"",
          type:"tabs" },
        values:{ layout:"page",
          permalink:"/:title/" } },
      { scope:{ path:"assets/js/dist" },
        values:{ swcache:true } } ],
    sass:{ style:"compressed" },
    compress_html:{ clippings:"all",
      comments:"all",
      endings:"all",
      profile:false,
      blanklines:false,
      ignore:{ envs:[ "development" ] } },
    exclude:[ "*.gem",
      "*.gemspec",
      "docs",
      "tools",
      "README.md",
      "LICENSE",
      "*.config.js",
      "package*.json" ],
    "jekyll-archives":{ enabled:[ "categories",
        "tags" ],
      layouts:{ category:"category",
        tag:"tag" },
      permalinks:{ tag:"/tags/:name/",
        category:"/categories/:name/" } } };
  var baseurl = data.baseurl;

  importScripts("".concat(baseurl, "/assets/js/data/swconf.js"));
  const purge = swconf.purge;
  function verifyUrl(url) {
    const requestPath = new URL(url).pathname;
    for (const path of swconf.denyPaths) {
      if (requestPath.startsWith(path)) {
        return false;
      }
    }
    return true;
  }
  self.addEventListener('install', event => {
    if (purge) {
      return;
    }
    event.waitUntil(caches.open(swconf.cacheName).then(cache => {
      return cache.addAll(swconf.resources);
    }));
  });
  self.addEventListener('activate', event => {
    event.waitUntil(caches.keys().then(keyList => {
      return Promise.all(keyList.map(key => {
        if (purge) {
          return caches.delete(key);
        } else {
          if (key !== swconf.cacheName) {
            return caches.delete(key);
          }
        }
      }));
    }));
  });
  self.addEventListener('message', event => {
    if (event.data === 'SKIP_WAITING') {
      self.skipWaiting();
    }
  });
  self.addEventListener('fetch', event => {
    if (event.request.headers.has('range')) {
      return;
    }
    event.respondWith(caches.match(event.request).then(response => {
      if (response) {
        return response;
      }
      return fetch(event.request).then(response => {
        const url = event.request.url;
        if (purge || event.request.method !== 'GET' || !verifyUrl(url)) {
          return response;
        }

        // See: <https://developers.google.com/web/fundamentals/primers/service-workers#cache_and_return_requests>
        let responseToCache = response.clone();
        caches.open(swconf.cacheName).then(cache => {
          cache.put(event.request, responseToCache);
        });
        return response;
      });
    }));
  });

})();
//# sourceMappingURL=sw.min.js.map
